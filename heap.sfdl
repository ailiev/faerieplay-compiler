/* -*- c -*-
* Alice has a min heap, bob has nothing
* Bob gets the min element,
* Alice gets a new min-heap without that element
*/
program Heaps {

  const logN = 16;
  const N = (1 << logN) - 1;
  
  type Key = Int<logN`>;
  type Idx = Int<logN`>;
  
  type Val = Int<20`>;
  
  type HeapItem = struct {Key key, Val data };

  type Heap     = struct { Int<logN`> size,
						   HeapItem[N] array };
  
  type AliceT   = struct { Heap input,
			   Heap output };
	
  type BobT     = struct { HeapItem output };
	
	
  function Idx left (Idx i1) {
    left = i1+i1;
  };

  function Idx right (Idx i1) {
    right = i1+i1+1;
  };
  
  function Heap min_heapify (Heap h, Idx i) {

    var Idx l;
    var Idx r;
    var Idx smallest;
    var HeapItem tmp;
    
    for (level = 0 to logN-2) {
      
      l = left(i);
      r = right(i);
    
      // get the argmin of A[i], A[r] and A[l]
      if (l <= h.size && h.array[l].key < h.array[i].key) {
		  smallest = l;
      }
      else {
		  smallest = i;
      }

      if (r <= h.size && h.array[r].key < h.array[smallest].key) {
		  smallest = r;
      }

      if (smallest != i) {
		  // exchange h[i] and h[smallest]
		  tmp = h.array[i];
		  h.array[i] = h.array[smallest];
		  h.array[smallest] = tmp;
		  i = smallest;
      }
      else {
		  i = r;			// arbitrary
      }

    }

    min_heapify = h;
  };


  function AliceT main (AliceT alice, BobT bob) {

    var Heap h;

    h = alice.input;
    
    bob.output = h.array[0];

    h.array[0] = h.array [h.size];
    h.size = h.size - 1;

    main.output = min_heapify (h, 0);

  };


}
