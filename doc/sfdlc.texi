\input texinfo 

@c %**start of header
@setfilename sfdlc.info
@include values.texi
@include version.texi

@settitle sfdlc @value{VERSION}
@c %**end of header

@c do not break page for new chapter
@setchapternewpage off


@macro termin {text}
@emph{\text\}
@end macro

@copying
Permission is granted ... this sofware

Permission is granted ... this manual ...

Permission is granted 

Copyright @copyright{} 2005--2008 Alexander Iliev
@end copying

@titlepage
@title sfdlc
@subtitle Documentation for version @value{VERSION}
@author Alexander Iliev
@page
@vskip 0pt plus 1fill
@insertcopying
@end titlepage

@iftex
@contents
@end iftex


@c ---  Introduction  ---

@dircategory Development
@direntry
* sfdlc: (sfdlc).                           Faerieplay circuit compiler.
@end direntry

@ifnottex
@node Top, Introduction
@top sfdlc

Sfdlc is a circuit compiler---it takes a high-level program and
produces an arithmetic circuit with some special constructs. The
circuit can be produced in a variety of formats.
@end ifnottex


@menu
* Introduction::        Getting started
* Source Languages::    Sfdlc's high-level language support.
* Circuit Programming:: Discussion on programming for an arithmetic circuit executable target.
* Prerequisites::       What you need installed to use sfdlc.
* Invoking sfdlc::      Invocation
* File types produced:: The myriad files that sfdlc produces
* Debugging::           Debugging your high-level code.
@end menu

@node Introduction
@chapter Introduction

Sfdlc is a special-purpose compiler which translates a program written
in a high-level imperative language into an arithmetic circuit with some extensions.

It currently supports two high-level languages
@itemize @bullet
@item Secure Function Definition Language (SFDL), which is a simple hybrid of C and
Pascal, introduced in the Fairplay porject), and
@item a subset of C++, which we call FC++.
@end itemize

The target arithmetic circuit has some extended gates for handling
indirect arrays efficiently.

The circuit is intended to be executed on the Faerieplay Circuit
Virtual Machine, whose main goal is to execute arbitrary programs
securely, in the sense that an adversary located outside a specified
trusted area, where the circuit evaluator runs, is not able to learn
anything about the program execution. In particular, the trusted area
is a @termin{Secure Coprocessor}, which is secure even against a local
adversary who tries to attack it physically. We have used the IBM 4758
secure coprocessor.

In this manual we focus on the operational aspects of the compiler,
and point to chapter 6 of Alex's dissertation for more extensive
commentary on topics like limitations of circuit programming, and
debugging in this environment.

@node Source Languages
@chapter Source Languages

The Faerieplay compiler supports Secure Function Definition Language
(SFDL) (a simple hybrid of C and Pascal, introduced in the Fairplay
porject) and a subset of C++, which we call FC++.

The syntax reference documents for the languages, generated by the
@file{bnfc}@footnote{@indicateurl{http://www.cs.chalmers.se/~markus/BNFC/}}
parser-generator tool, are available in the files
@file{Sfdl/@value{SyntaxFile}} and @file{Fcpp/@value{SyntaxFile}}.

Example files for the two languages are available in the @file{examples/}
directory.

@section SFDL

The syntax of the langugage is illustrated in the examples files inside
@file{examples/Sfdl/}, and specified formally in the syntax file @file{Sfdl/@value{SyntaxFile}}.


@subsection Semantics

The more interesting semantics of Faerieplay SFDL are:
@itemize @bullet

@item The entry point of a program is the function @command{sfdlmain}, which may have any type signature, corresponding to the input and output types of the program.

@item Variables, including array elements, are implicitly initialized with zero-values.

@item Function parameters are usually passed by value. Reference paramaters can be specified as in C++, with a '&' qualifier.

@item Values are returned from a function as in Pascal, by assigning to a
(implicitly declared) variable of the same name and type as the function. It is
an error to actually declare such a variable in the function.

@item Functions cannot be called before they are defined. This is one of the reasons that recursive or mutually recursive functions are not currently supported.

@item Since important constructs like loop limits must be constant expressions, it is important to know what a constant expression is. Currently the compiler recoognizes the following as constant:
@itemize @minus
@item A literal,
@item A defined constant,
@item An expression involving only constant expressions.
@end itemize
Currently the compiler does not recognize constant functions---there cannot be function calls in a constant expression.


@end itemize



@subsection Limitations

The language semantics have some limitations due to the static nature of the
executable target---one-pass circuits. These limitations apply to all Faerieplay
source languagues, and are described in @ref{Circuit Programming}.



@section FC++

@subsection Additional requirements

@sfdlc supports a subset of C++, which we call FC++, in order to allow a user to use existing C++ development toolchains for tasks like debugging, while using @sfdlc and the Faerieplay CVM for secure execution.

FC++ has a slightly different syntax than C++, in order to ease
parsing. The differences are:
@itemize @bullet
@item
Variable declarations are preceded by the keyword @code{var}.

@item
Function declarations are preceded by the keyword @code{function}.

@item
The whole program is preceded by a line:

@code{program <name>;}

@end itemize


Every FC++ file should start with @code{#include <sfdl-crutches.h>},
which will pull in any preprocessor definitions needed to have FC++
code compiled by a regular C++ compiler.

@subsection Which subset of C++?

Here are the restrictions of FC++ with respect to standard C++.

@itemize @bullet
@item No pointer syntax or usage.

@item No templates, except for the FC++ built-in array and Integer types.

@item None of the standard headers are supported---it is unlikely that any existing C++ headers will work with FC++.

@item @code{const} can only appear in front of integer declations.

@item No general templates.

@item Array syntax is limited to the syntax of the @file{boost} C++ library:
      @itemize @bullet

      @item An N-element array of T's has type @code{array<T, N>},
where @var{N} can be a static expression.

      @end itemize
Standard C/C++ array syntax is not supported. Multi-dimentional arrays
are specified as in boost: @code{array<array<T,N1>, N2>}.

@end itemize


@node Circuit Programming
@chapter Circuit Programming


@node Prerequisites
@chapter Prerequisites

@section Boost array library

FC++ represents arrays as the Boost array class
@footnote{@indicateurl{http://www.boost.org/doc/html/array.html}}.
Thus, the Boost array library needs to be available in order to
compile FC++ code with a C++ compiler.


@node Invoking sfdlc
@chapter Invoking

The basic invocation syntax is:

@example
sfdlc [ options ] file.@value{SRCEXT}.
@end example


@code{sfdlc} understands the following options:


@table @samp
       
@item -h
Print out the help text and exit.

@item -o @var{FILE}
@itemx --output=@var{file}

Write output to @var{file}.


@item -c
@itemx --compile
Compile. This is the default action.



Write output to @var{file}.


@end table


@node File types produced
@chapter File types that @command{sfdlc} produces.


@command{sfdlc} produces the following kinds of files from its various actions.

@section Executable circuit

This is the file which is given to the circuit virtual machine for execution.
Extension: @file{.runtime}.

@section Circuit graph in internal format

This is a dump of the circuit graph, before it is serialized. Extension: @file{.cct}.

@section List of gates in internal format

This is a dump of the circuit after it is serialized, but in the compiler's internal format. Extension: @file{.gates}.

@section UDrawGraph file

This is a representation of the circuit for the UDrawGraph program. Extension: @file{.udg}.

@section A circuit simulation trace

This is produced by the circuit simulation, and consists of the values generated
for each gate, in the order they occur in the serialized circuit. Extension:
@file{.run}.


@node Debugging
@chapter Debugging

Sfdlc provides several mechanisms for debugging high-level code:
@itemize @bullet
@item A circuit emulator which prints a trace of gate values during executions.
@item A print statement which produces a gate which prints several values as its result.
@item If using C++, the possibility to use another toolset for debugging.
@end itemize


@bye
