module Main where

import List     (unfoldr, find, elemIndex)
import Maybe    (isJust, fromJust, fromMaybe, listToMaybe)
import System   (getArgs, exitWith, ExitCode(..), getProgName)

import IO ( stdin, stderr,
            hGetContents, hPrint, hFlush, hPutStrLn, hPutStr,
            openFile, hClose,
            IOMode(..),
            ioeGetErrorString)

import qualified Distribution.GetOpt    as Opt
import Data.IORef                       (IORef,newIORef,readIORef,writeIORef)
import System.IO.Unsafe                 (unsafePerformIO)


import SFDL.Abs                  -- the abstract syntax types from BNFC
import SFDL.Lex                  -- Alex lexer
import SFDL.Par                  -- the Happy parser 
import SFDL.Print                -- generated by BNFC, to print an AST

import SFDL.ErrM

import qualified Data.Map as Map

import qualified Intermediate   as Im
import qualified HoistStms      as Ho
import qualified Unroll         as Ur
import qualified CircGen        as CG
import qualified Runtime        as Run


import TypeChecker

import SashoLib

-- NOTE: this is updated by emacs function time-stamp; see emacs "Local Variables:"
-- section at the end.
-- g_timestamp = "2006-06-12 13:05:49 sasho"

g_svn_id = "subversion $Revision$"

import qualified Text.PrettyPrint.HughesPJ as PP


main = do argv          <- getArgs
          name          <- getProgName
          let o@(opts,args,errs) = Opt.getOpt Opt.Permute optionControl argv
--          hPrint stderr o
          if (not $ null errs) then do hPutStrLn stderr "Command line errors:"
                                       mapM_ (hPutStrLn stderr) errs
                                       hPutStrLn stderr $ usage name
                                       exitWith ExitSuccess
                               else return ()
          -- bring the action to the front by sorting
          let (action:_)    = sort opts
          case action of
            Version     -> do putStrLn $ name ++ " Version " ++ version

          if elem Help opts then do name     <- getProgName
                                    hPutStrLn stderr $ usage name
                                    exitWith ExitSuccess
                            else return () -- carry on with main

          let mb_infile = listToMaybe args

          -- save away the flags and input file name
          writeIORef g_Flags (opts, mb_infile)

          -- get the input handle, a file or stdin
          hInfile       <- maybe  (return stdin)
                                  (\infile ->
                                       (openFile infile ReadMode)
                                           `catch`
                                       (\e -> do putStrLn $
                                                   "failed to open " ++
                                                   infile ++
                                                   ": " ++
                                                   ioeGetErrorString e
                                                 exitWith $ ExitFailure 2))
                                  mb_infile

          let mb_runfile    = extrRunFile opts
          case mb_runfile of (Just mb_f)-> let -- default output will be to a.run
                                               infile   = fromMaybe "a.cct" mb_infile
                                               fname    = fromMaybe (modFileExt infile "run")
                                                                    mb_f
                                           in
                                             doRunCct hInfile fname

                             Nothing    -> hGetContents hInfile >>= run 1 pProg



------------
-- command line argument processing stuff
------------
g_Flags :: IORef ([Flag],       -- flags
                  Maybe String) -- (optional) input file name
g_Flags = unsafePerformIO $ newIORef ([], Nothing)

data Flag 
    = 
      -- actions:
      Version
    | Runfile (Maybe String)
    | Graph   (Maybe String)
      -- options:
    | Verbose
    | Help
    | Input String
    | Output (Maybe String)
    | LibDir String
      deriving (Eq,Ord,Show)
    
optionControl :: [Opt.OptDescr Flag]
optionControl =
    [ Opt.Option ['v']      ["verbose"] (Opt.NoArg Verbose)             "Chatty output on stderr"
    , Opt.Option ['V','?']  ["version"] (Opt.NoArg Version)             "Show version number"
    , Opt.Option ['o']      ["output"]  (Opt.OptArg Output "<file>")    "Output circuit to <file>"
    , Opt.Option ['h']      ["help"]    (Opt.NoArg Help)                "Print help (this text)"
    , Opt.Option ['r']      ["run"]     (Opt.OptArg Runfile "<file>")   "Run circuit into <file>"
    , Opt.Option ['g']      ["graph"]   (Opt.NoArg Graph)               "Generate a gviz graph file"
     ]

usage name = Opt.usageInfo ("Usage: " ++ name ++
                            " <options> <input file>\n" ++
                            "Produces <output> and cct.gviz\n" ++
                            "Options:")
                           optionControl


-- extract various options from the global options list
getOutFile = do (flags,_)   <- readIORef g_Flags
                return ( do (Output f) <- find isOut flags -- Maybe monad
                            return f )
    where isOut (Output _)  = True
          isOut _           = False

getRunFile = do (flags,_)   <- readIORef g_Flags
                return $ extrRunFile flags

getInFile = do (_,mb_infile) <- readIORef g_Flags
               return $ fromJustMsg "No actual input file specified"
                                    mb_infile


extrRunFile flags =     do (Runfile f) <- find isRunFile flags -- Maybe monad
                           return f
    where isRunFile (Runfile _) = True
          isRunFile _           = False


type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = if v > 1 then putStrLn s else return ()

{-
showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree
 = do
      putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
      putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree
-}

--run :: (Print a, Show a) => Verbosity -> ParseFun a -> String -> IO ()
run v parser input =
    let tokens  = myLexer input
        ast     = parser tokens
    in case ast of
         Bad s    -> do putStrLn "\nParse Failed...\n"
                        putStrV v "Tokens:"
                        putStrV v $ show tokens
                        putStrLn s
         Ok  prog@(Prog _ _) ->
           do putStrLn "\nParse Successful!"
              case typeCheck prog of
                (Left err)        -> print $ "Type Error! " << err
                (Right prog@(Im.Prog pname
                             Im.ProgTables {Im.types=typ_table,
                                            Im.funcs=fs}))      ->
                   do hPrint stderr prog
                      putStrLn "Typechecking done"

                      let prog_flat = Ho.flattenProg prog
                      hPrint stderr prog_flat
                      putStrLn "Flattened program"
                      case Ur.unrollProg prog_flat of
                        (Left err)       -> print $ "Unrolling Error! " << err
                        (Right stms)     ->
                           do hPrint stderr (PP.vcat (map Im.docStm stms))
                              putStrLn "Unrolled main"
--                              return () -- in case we want to exit before circuit generation

                              infile         <- getInFile
                              mb_outfile_opt <- getOutFile
                              let mb_outfile    = fromMaybe Nothing
                                                            mb_outfile_opt
                                  gatesFile     = fromMaybe (modFileExt infile "cct")
                                                            mb_outfile
                                  runtimeFile   = modFileExt gatesFile "runtime"
                                  graphFile       = modFileExt infile "gviz"

                                  -- and compile the circuit
                                  args          = CG.extractInputs prog
                                  (cct,gates)   = CG.genCircuit typ_table stms args

                              putStrLn $ "Generating the circuit ..."
                              h     <- openFile runtimeFile WriteMode
                              mapM_ (hPutStr h . CG.cctShow) gates
                              hClose h
                              putStrLn $ "Wrote the circuit runtime form to " ++ runtimeFile

                              putStrLn $ "Now generating the circuit graph out to " ++ graphFile
                              writeFile graphFile (CG.showCct cct)
{-
                              putStrLn $ "Writing the gate list to " ++ gatesFile
                              writeGates gatesFile gates
-}




doRunCct cct_fh outfile = 
    do putStrLn ("Now running the circuit into " ++ 
                 outfile)
       gates    <- hGetContents cct_fh >>= readIO
       ins      <- Run.getUserInputs gates
       h        <- openFile outfile WriteMode
       vals     <- Run.formatRun gates ins
       mapM_ (hPutStrLn h) vals
       hClose h

       


modFileExt file newext = let name = takeWhile (/= '.') file
                         in  name ++ "." ++ newext

--                                   mapM_ print cct

{-
                                                        (stms,errs') ->
--                                                          errs' = strictList errs
                                                            do print (PP.vcat (map Im.docStm stms))
                                                               print errs'
{-
                                                      if not $ null errs'
                                                         then putStrLn "Failed!" -- >> print errs'
                                                         else return ()
-}
-}

writeGates file gates = do h        <- openFile file WriteMode
                           -- mapM (hPrint h) gates
                           hPrint h gates
                           hClose h


printMap m = mapM_ print $ Map.fold (:) [] m

getMain (Im.Prog _ (Im.ProgTables {Im.funcs=fs})) =
    fromJust $ Map.lookup "main" fs
        
testFlatten (Im.Prog pname (Im.ProgTables {Im.funcs=fs})) fname =
    do let (Just f) = Map.lookup fname fs
           f_flat = Ho.flattenFunc f
       print f_flat

--                                 Prog _ decls -> case head decls of
--                                                      FunDecl _ _ _ _ stms -> print $ unrollStms stms
                                                 --                                                                    showTree v $ Fun TInt (Ident "unrolled") unrolled


{-
Local Variables:
time-stamp-start:"g_timestamp[ 	]*=[ 	][\"]"
time-stamp-line-limit:60
End:
-}
