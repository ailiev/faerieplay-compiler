#
# Circuit compiler for the Faerieplay hardware-assisted secure
# computation project at Dartmouth College.
#
# Copyright (C) 2003-2007, Alexander Iliev <sasho@cs.dartmouth.edu> and
# Sean W. Smith <sws@cs.dartmouth.edu>
#
# All rights reserved.
#
# This code is released under a BSD license.
# Please see LICENSE.txt for the full license and disclaimers.
#

include config.make

# Set a bunch of make variables
# note: currently do not use all the ghc settings, but build via cabal.
include do_setup.make

# generated by cabal
EXES = dist/build/fc++/fc++ dist/build/sfdlc/sfdlc

# Generated by update-versions.pl and used to track versions across the source
# files.
VERSFILE = Faerieplay/Version.hs

all: $(VERSFILE) $(EXES) doc
#	@echo srcs = $(SRCS)
#	@echo vers file = $(VERSFILE)

install: all
	cabal install
	install -p $(EXES) $(DIST_ROOT)/bin/

$(EXES): | bnfc
	cabal configure && cabal build


SRCS = $(shell find $(CURDIR)/Faerieplay -name '*.hs' -o -name '*.cf') 

doc:
	$(MAKE) -C doc
.PHONY: doc


##############################
## version management
##############################

# Both $(VERSFILE) and $(VERSFILE).tok are kept in svn. $(VERSFILE).tok is a
# static template, while $(VERSFILE) is updated with version summary info, so it
# changes if any other source file changes. Then upon checkin, svn updates the
# version info in $(VERSFILE) to be the same as the latest modified source file.

$(VERSFILE): $(VERSFILE).tok $(SRCS)
	$(CURDIR)/update-versions.pl < $(VERSFILE).tok > $(VERSFILE) $(CURDIR)


ifdef TOOLS_DIR
# alex and happy are not quite smart enough to find their helper files relative
# to the executable, so we have to tell them.
ifneq ($(empty), $(wildcard $(TOOLS_DIR)/$(ALEX_SUBDIR)))
ALEXFLAGS += --template=$(TOOLS_DIR)/$(ALEX_SUBDIR)
endif

ifneq ($(empty), $(wildcard $(TOOLS_DIR)/$(HAPPY_SUBDIR)))
HAPPYFLAGS += --template=$(TOOLS_DIR)/$(HAPPY_SUBDIR)
endif

endif

bnfc_root_dir = Faerieplay/Bnfc

# eg Fcpp.cf -> Fcpp
bnfc_lang = $(basename $(<))
# eg Fcpp.cf -> Faerieplay.Bnfc.Fcpp
bnfc_lang_dir = $(bnfc_root_dir)/$(bnfc_lang)

bnfc_generated_files=Par.y Lex.x Doc.pdf
bnfc_generated_paths=$(patsubst %,$(bnfc_root_dir)/$(1)/%,$(bnfc_generated_files))
bnfc: $(call bnfc_generated_paths,Sfdl) $(call bnfc_generated_paths,Fcpp)

$(bnfc_root_dir)/%/Par.y $(bnfc_root_dir)/%/Lex.x $(bnfc_root_dir)/%/Doc.pdf : %.cf
	bnfc -haskell -d -p Faerieplay.Bnfc $<
	happy $(HAPPYFLAGS) -gca $(bnfc_lang_dir)/Par.y
	alex $(ALEXFLAGS) -g $(bnfc_lang_dir)/Lex.x
	(cd $(bnfc_lang_dir); pdflatex Doc.tex)
	ed $(bnfc_lang_dir)/Abs.hs < add-bnfc-derives.ed
	ghc --make $(bnfc_lang_dir)/Test.hs -o $(bnfc_lang_dir)/Test

# this make shouldnt look at the compiled sfdlc file--hmake or ghc do that.
.PHONY: $(EXE) bnfc dep

clean:
	$(MAKE) -C doc clean
	$(RM) -r $(ODIR)/*
	$(RM) -r $(bnfc_root_dir)/*
	cabal clean

tags: TAGS

# hasktags is no longer part of ghc, since 6.12.
# but can install it from hackage:
# cabal install hasktags
# other tags options:
# http://www.haskell.org/haskellwiki/Tags#Haskell_tag_generators
TAGS: $(SRCS)
	hasktags --etags $^

# have this here, as a standard target, even if empty.
dep:

# to make postscript of a circuit (or any) gviz file:
#  dot -Tps cct.gviz -o cct.ps
