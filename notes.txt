Analysis of what is static and what not:

Could check all expressions which should be static (eg. consts, int size, array
length) during first typecheck phase. but this is nasty to mix with actual
typechecking.

Perhaps have a second pass right away, which actually computes all available
static expressions? 

All consts should be available before unrolling? yes!

how to deal with structs?? name + offset? a set of separate names?



Sun Jun  5 17:37:53 2005

Current implementation of HoistStms will not handle a function call in an
l-value. this seems fairly sensible to prohibit.


Mon Jun 13 20:16:32 2005

notes on Graph:

type Adj b = [(b, Node)]
Labeled links to or from a Node.

type Context a b = (Adj b, Node, a, Adj b)
Links to the Node, the Node itself, a label, links from the Node.

> a is the type of vertex labels, and b is the type of edge labels



Thu Jun 16 23:52:00 2005

recursive types are causing a hassle with the circuit generator var table being
keyed on Var. We can only keep the gate locations of Var. but what about:
struct Point = { int x, int y }
struct Shoes = { int number, bool torn, Color col }
struct Globals = { Point center, Shoes shoes, int age }
// ...
var Globals g;
var Point p1;
// ...
g.center = p1;
g.center.x = 0;


POINT: var tables should be keyed on +/- what appears as an lval:
EVar
EStruct
EArr
or (stripped down) Exp in general?


g = ...
// ...

if () {
   var Globals g;
   // ...
   g.center.x = 0;
}

