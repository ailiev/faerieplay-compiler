module Main where

import List (unfoldr)
import Maybe (isJust, fromJust)

import IO ( stdin, hGetContents )

import AbsSFDL                  -- the abstract syntax types from BNFC
import LexSFDL                  -- Alex lexer
import ParSFDL                  -- the Happy parser 
import PrintSFDL                -- generated by BNFC, to print an AST

import ErrM


-- unroll a for-loop
unrollFor :: Stm -> [Stm]
unrollFor for@(SFor _ (EInt lo) (EInt hi) _) = concat $ unfoldr unroll1 (for, lo)
          -- unrolled enough when loop counter exceeds 'hi'
    where unroll1 (_, cur)  | cur > hi               = Nothing
          -- substitute in the value of the loop counter, and then recursively unroll
          unroll1 (for@(SFor var _ _ stmts) , cur)   = let substed  = map (subst var (EInt cur)) stmts
                                                           unrolled = concatMap unrollFor substed
                                                       in Just (unrolled, (for,cur+1))
unrollFor stm                                = [stm] -- non-for statements not unrolled


-- substitute a value for a variable into a statement
subst :: Var -> Exp -> Stm -> Stm
subst var _   (SAss var2 _  )   | var == var2 = error "Assigning to loop variable"
subst var _   (SFor var2 _ _ _) | var == var2 = error "Outer loop var reused as inner loop var"
subst var _   (SDecl _ var2)    | var == var2 = error "Redeclaring loop variable in loop"
subst var val (SFor var2 elo ehi stmts)       = SFor var2
                                                     (substExp var val elo)
                                                     (substExp var val ehi)
                                                     (map (subst var val) stmts)
subst var val (SIf test stmts)                = SIf (substExp var val test)
                                                    (map (subst var val) stmts)
subst var val (SAss var2 exp)                 = SAss var2 (substExp var val exp)
subst _   _   stm                             = stm


-- substitue a value for a var into an exp
--          var    val    exp    result
substExp :: Var -> Exp -> Exp -> Exp
substExp var val (EVar var2) | var == var2  = val
-- one entry for binary operations, with the help of extrBinOp
-- this whole rigmarole is because Haskell will not take:
-- substExp var val (eBinOp e1 e2)              = (eBinOp  (substExp var val e1) (substExp var val e2))
-- ie. a variable for the data constructor
-- substExp var val exp | isJust fields = let (op, e1, e2) = fromJust fields
--                                        in  op (substExp var val e1) (substExp var val e2)
--                      where fields = extrBinOpFields exp
-- and using GHC pattern guards:
substExp var val exp
    | Just (op, e1, e2) <- extrBinOpFields exp = op (substExp var val e1) (substExp var val e2)
substExp _   _   exp                        = exp


extrBinOpFields :: Exp -> Maybe ( (Exp -> Exp -> Exp), Exp, Exp )
extrBinOpFields (ETimes e1 e2) = Just (ETimes, e1, e2)
extrBinOpFields (EPlus  e1 e2) = Just (EPlus, e1, e2)
extrBinOpFields (ELt    e1 e2) = Just (ELt, e1, e2)
extrBinOpFields _              = Nothing


main = hGetContents stdin >>= run 2 pProg


type ParseFun a = [Token] -> Err a
type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = if v > 1 then putStrLn s else return ()

showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree
 = do
      putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
      putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree


-- run :: (Print a, Show a) => Verbosity -> ParseFun a -> String -> IO ()
run v p s = let ts =  myLexer s
                ast = p ts
            in case ast of
                        Bad s    -> do putStrLn "\nParse              Failed...\n"
                                       putStrV v "Tokens:"
                                       putStrV v $ show ts
                                       putStrLn s
--                         Ok  tree -> do putStrLn "\nParse Successful!"
--                                        showTree v tree
                        Ok  tree -> do putStrLn "\nParse Successful!"
                                       putStrV v "Unrolling for's"
                                       case tree of
                                                 Fun _ _ stms -> do let unrolled = concatMap unrollFor stms
                                                                    showTree v $ Fun TInt (Ident "unrolled") unrolled
