module Main where

import List     (unfoldr, find)
import Maybe    (isJust, fromJust, fromMaybe)
import System   (getArgs, exitWith, ExitCode(ExitSuccess,ExitFailure))

import IO ( stdin, stderr,
            hGetContents, hPrint, hFlush, hPutStrLn,
            openFile, hClose,
            IOMode(..),
            ioeGetErrorString)

import qualified Distribution.GetOpt    as Opt
import Data.IORef                       (IORef,newIORef,readIORef,writeIORef)
import System.IO.Unsafe                 (unsafePerformIO)


import SFDL.Abs                  -- the abstract syntax types from BNFC
import SFDL.Lex                  -- Alex lexer
import SFDL.Par                  -- the Happy parser 
import SFDL.Print                -- generated by BNFC, to print an AST

import SFDL.ErrM

import qualified Data.Map as Map

import qualified Intermediate   as Im
import qualified HoistStms      as Ho
import qualified Unroll         as Ur
import qualified CircGen        as CG


import TypeChecker

import SashoLib

import qualified Text.PrettyPrint.HughesPJ as PP


main = do argv          <- getArgs
          let o@(opts,args,errs) = Opt.getOpt Opt.Permute optionControl argv
--          hPrint stderr o
          if (not $ null errs) then do hPutStrLn stderr "Command line errors:"
                                       mapM_ (hPutStrLn stderr) errs
                                       hPutStrLn stderr $ Opt.usageInfo "Usage:\n" optionControl
                                       exitWith ExitSuccess
                               else return ()

          writeIORef g_Flags opts

          hInfile       <- if null args
                           then return stdin
                           else let infile = head args in
                                (openFile infile ReadMode)
                                    `catch`
                                (\e -> do putStrLn $ "failed to open " ++
                                                       infile ++
                                                       ": " ++
                                                       ioeGetErrorString e
                                          exitWith $ ExitFailure 2)
          (hGetContents hInfile >>= run 1 pProg)



------------
-- command line argument processing stuff
------------
g_Flags :: IORef [Flag]
g_Flags = unsafePerformIO $ newIORef []

data Flag 
    = Verbose  | Version 
    | Input String | Output String | LibDir String
      deriving Show
    
optionControl :: [Opt.OptDescr Flag]
optionControl =
    [ Opt.Option ['v']     ["verbose"] (Opt.NoArg Verbose)       "chatty output on stderr"
    , Opt.Option ['V','?'] ["version"] (Opt.NoArg Version)       "show version number"
    , Opt.Option ['o']     ["output"]  (Opt.ReqArg Output "FILE")  "output FILE"
--    , Opt.Option ['c']     []          (Opt.OptArg inp  "FILE")  "input FILE"
     ]

-- extract the output file from the global flags
getOutFile = do flags   <- readIORef g_Flags
                let (Output outName) = fromJust $ find isOut flags
                return outName
    where isOut (Output _)  = True
          isOut _           = False


type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = if v > 1 then putStrLn s else return ()

{-
showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree
 = do
      putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
      putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree
-}

--run :: (Print a, Show a) => Verbosity -> ParseFun a -> String -> IO ()
run v parser input =
    let tokens  = myLexer input
        ast     = parser tokens
    in case ast of
         Bad s    -> do putStrLn "\nParse Failed...\n"
                        putStrV v "Tokens:"
                        putStrV v $ show tokens
                        putStrLn s
         Ok  prog@(Prog _ _) ->
           do putStrLn "\nParse Successful!"
              case typeCheck prog of
                (Left err)        -> print $ "Type Error! " << err
                (Right prog@(Im.Prog pname
                             Im.ProgTables {Im.types=typ_table,
                                            Im.funcs=fs}))      ->
                   do putStrLn "After typechecking:"
                      hPrint stderr prog
                      let prog_flat = Ho.flattenProg prog
                      putStrLn "Flattened program:"
                      hPrint stderr prog_flat
                      case Ur.unrollProg prog_flat of
                        (Left err)       -> print $ "Unrolling Error! " << err
                        (Right stms)     ->
                           do putStrLn "Unrolled main:"
                              hPrint stderr (PP.vcat (map Im.docStm stms))
                              gatesFile       <- getOutFile
                              let cctFile      = "cct.gviz"
                                  args         = CG.extractInputs prog
                                  (cct,gates)  = CG.genCircuit typ_table stms args
                              hPrint stderr cct; hFlush stderr
                              putStrLn $ "Now writing the circuit out to " ++ cctFile
                              writeFile cctFile (CG.showCct cct)
                              putStrLn $ "Writing the gate list to " ++ gatesFile
                              writeGates gatesFile gates
--                                   mapM_ print cct

{-
                                                        (stms,errs') ->
--                                                          errs' = strictList errs
                                                            do print (PP.vcat (map Im.docStm stms))
                                                               print errs'
{-
                                                      if not $ null errs'
                                                         then putStrLn "Failed!" -- >> print errs'
                                                         else return ()
-}
-}

writeGates file gates = do h        <- openFile file WriteMode
                           mapM (hPrint h) gates
                           hClose h


printMap m = mapM_ print $ Map.fold (:) [] m

getMain (Im.Prog _ (Im.ProgTables {Im.funcs=fs})) =
    fromJust $ Map.lookup "main" fs
        
testFlatten (Im.Prog pname (Im.ProgTables {Im.funcs=fs})) fname =
    do let (Just f) = Map.lookup fname fs
           f_flat = Ho.flattenFunc f
       print f_flat

--                                 Prog _ decls -> case head decls of
--                                                      FunDecl _ _ _ _ stms -> print $ unrollStms stms
                                                 --                                                                    showTree v $ Fun TInt (Ident "unrolled") unrolled
