module Main where

import List (unfoldr)
import Maybe (isJust, fromJust)

import IO ( stdin, hGetContents )

import SFDL.Abs                  -- the abstract syntax types from BNFC
import SFDL.Lex                  -- Alex lexer
import SFDL.Par                  -- the Happy parser 
import SFDL.Print                -- generated by BNFC, to print an AST

import SFDL.ErrM

import qualified Data.Map as Map

import qualified Intermediate   as Im
import qualified HoistStms      as Ho
import qualified Unroll         as Ur
import qualified CircGen        as CG

import TypeChecker

import SashoLib

import qualified Text.PrettyPrint.HughesPJ as PP




main = hGetContents stdin >>= run 2 pProg


type ParseFun a = [Token] -> Err a
type Verbosity = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = if v > 1 then putStrLn s else return ()

showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree
 = do
      putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
      putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree


-- run :: (Print a, Show a) => Verbosity -> ParseFun a -> String -> IO ()
run v p s =
    let ts =  myLexer s
        ast = p ts
    in case ast of
         Bad s    -> do putStrLn "\nParse              Failed...\n"
                        putStrV v "Tokens:"
                        putStrV v $ show ts
                        putStrLn s
         Ok  tree ->
           do putStrLn "\nParse Successful!"
              case tree of
                prog@(Prog _ _) ->
                  case typeCheck prog of
                    (Left err)        -> print $ "Error! " << err
                    (Right prog@(Im.Prog pname
                                         Im.ProgTables {Im.types=ts,
                                                        Im.funcs=fs}))      ->
                       do putStrLn "After typechecking:"
                          print prog
                          let prog_flat = Ho.flattenProg prog
                          putStrLn "Flattened program:"
                          print prog_flat
                          case Ur.unrollProg prog_flat of
                            (Left err)       -> print $ "Error! " << err
                            (Right stms)     ->
                                do putStrLn "Unrolled main:"
                                   print (PP.vcat (map Im.docStm stms))
                                   let cctFile = "cct.gviz"
                                   putStrLn $ "And now generating the circuit into " ++ cctFile
                                   let args = CG.extractInputs prog
                                       cct  = CG.genCircuit ts stms args
--                                   mapM_ print cct
                                   writeFile cctFile(CG.showCct cct)

{-
                                                        (stms,errs') ->
--                                                          errs' = strictList errs
                                                            do print (PP.vcat (map Im.docStm stms))
                                                               print errs'
{-
                                                      if not $ null errs'
                                                         then putStrLn "Failed!" -- >> print errs'
                                                         else return ()
-}
-}

printMap m = mapM_ print $ Map.fold (:) [] m

getMain (Im.Prog _ (Im.ProgTables {Im.funcs=fs})) =
    fromJust $ Map.lookup "main" fs
        
testFlatten (Im.Prog pname (Im.ProgTables {Im.funcs=fs})) fname =
    do let (Just f) = Map.lookup fname fs
           f_flat = Ho.flattenFunc f
       print f_flat

--                                 Prog _ decls -> case head decls of
--                                                      FunDecl _ _ _ _ stms -> print $ unrollStms stms
                                                 --                                                                    showTree v $ Fun TInt (Ident "unrolled") unrolled
