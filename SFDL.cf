-- -*- haskell -*-
-- Javalette Light: a simple subset of C, covering
-- programs with a single zero-argument function.
-- example: koe.jll

-- modified by sasho starting May 2005
-- to cover SFDL

-- NOTES:
--
-- There is 1 shift-reduce conflict due to the classical
-- ambiguous if () {} else {}
-- putting a "fi" at the end of an if statement solves those, but
-- breaks current SFDL syntax.

---------------


-----------
-- ordinary rules
-----------

-- program
Prog.           Prog    ::= "program" Ident "{" [Dec] "}" ;

-- how are lists of Dec treated
--[].             [Dec]   ::= ;
--(:).            [Dec]   ::= Dec ";" [Dec] ;
separator Dec ";" ;

-- [].             [Stm]   ::= ;
-- (:).            [Stm]   ::= Stm ";" [Stm] ;
separator Stm   ";" ;


-- this is needed for Ident lists in enum types and var declarations.
separator nonempty Ident "," ;


-- declarations
ConstDecl.      Dec     ::= "const" Ident "=" Exp ;
TypeDecl.       Dec     ::= "type"  Ident "=" Typ ;
-- TypeDecl.       Dec     ::= "typedef"  Typ Ident ;
VarDecl.        Dec     ::= "var"   Typ [Ident] ;
FunDecl.        Dec     ::= "function" Typ Ident "(" [FieldDecl] ")"
                            "{" [Dec] [Stm] "}" ;

-----------
-- types
-----------

-- NOTE: semantically, the size Exp for Int and arrays has to be a
-- compile-time integer constant

-- FIXME: the bitsize of an Int should be an expression (even if a
-- compile-time exp) and not just an Integer. This is not doable with
-- this parse arrangement though, unless the <> syntax is dropped, eg
-- have:
--IntT.          Typ         ::= "Int" "<" Exp ">" ;
--IntT.          Typ         ::= "Int" "[<" Exp ">]" ;
IntT.          Typ         ::= "Int" "<" Integer ">" ;
BoolT.          Typ     ::= "Boolean" ;
VoidT.          Typ     ::= "void" ;

StructT.       Typ         ::= "struct" "{" [FieldDecl] "}" ;
EnumT.          Typ     ::= "enum" "{" [Ident] "}" ;
ArrayT.        Typ        ::= Typ "[" Exp "]" ;
SimpleT.        Typ     ::= Ident ;

-- this is a declaration of a named typed variable, like in a function
-- param list, or struct field
FieldDecl.   FieldDecl   ::= Typ Ident ;

-- fields in a struct are separated by commas
-- a void type can be defined as an empty struct. (TODO: or should the
-- compiler define one?)
-- both the above requirements apply to function arg lists too
-- separator FieldDecl "," ;
-- [].             [FieldDecl]   ::= ;
-- (:).            [FieldDecl]   ::= FieldDecl "," [FieldDecl] ;
separator FieldDecl "," ;


-- statements
SBlock.   Stm      ::= "{" [Dec] [Stm] "}" ;

SAss.     Stm      ::= RVal "=" Exp  ;

SFor.     Stm           ::= "for" "(" Var "=" Exp "to" Exp ")" Stm ;
SIf.      Stm      ::= "if" "(" Exp ")" Stm ;
SIfElse.        Stm     ::= "if" "(" Exp ")" Stm "else" Stm ;

-- to allow extra semicolons; no effect on the AST
-- PROBLEM: caused 5 reduce-reduce conflicts (when combined with empty
-- StmList possibility), so just took it out for now.
-- _.        Stm      ::= Stm ";" ;


RVal.           RVal    ::= Exp ;

--------------
-- expressions
--------------

EVar.     Exp12     ::= Ident ;
EInt.     Exp12     ::= Integer ;
EString.  Exp12     ::= String ;
ETrue.          Exp12    ::= "true" ;
EFalse.         Exp12    ::= "false" ;


EArr.           Exp12   ::= Exp12 "[" Exp "]" ;
EStruct.        Exp12   ::= Exp12 "." Ident ;

EFunCall.       Exp12   ::= Ident "(" [FunArg] ")" ;

-- binary operators, grouped by precedence, numbered as in the C
-- operator precedence man page (some are missing here, hence the gap
-- 4-6)
ENot.           Exp11   ::= "!" Exp12 ;
ENeg.           Exp11   ::= "-" Exp12 ;

ETimes.         Exp10   ::= Exp10 "*" Exp11 ;
EDiv.           Exp10   ::= Exp10 "/" Exp11 ;

EPlus.          Exp9    ::= Exp9 "+" Exp10 ;
EMinus.         Exp9    ::= Exp9 "-" Exp10 ;

ESL.            Exp8    ::= Exp9 "<<" Exp9 ;
ESR.            Exp8    ::= Exp9 ">>" Exp9 ;

ELt.            Exp7    ::= Exp8 "<" Exp8 ;
EGt.            Exp7    ::= Exp8 ">" Exp8 ;
ELtEq.          Exp7    ::= Exp8 "<=" Exp8 ;
EGtEq.          Exp7    ::= Exp8 ">=" Exp8 ;

EEq.            Exp6    ::= Exp7 "==" Exp7 ;
ENeq.           Exp6    ::= Exp7 "!=" Exp7 ;

EAnd.           Exp2    ::= Exp2 "&&" Exp3 ;

EOr.            Exp1    ::= Exp1 "||" Exp2 ;

coercions Exp 12 ;

-- function call arguments
FunArg.         FunArg  ::= Exp ;
separator FunArg "," ;


-- variables
VName.    Var      ::= Ident ;



-- pragmas

internal ExpT. Exp ::= Typ Exp ;

comment "/*" "*/" ;
comment "//" ;

entrypoints Prog, Stm, Exp ;
