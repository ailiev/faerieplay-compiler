-- -*- haskell -*-
-- Javalette Light: a simple subset of C, covering
-- programs with a single zero-argument function.
-- example: koe.jll

-- modified by sasho starting May 2005
-- to cover SFDL

-- NOTES:
--
-- There is 1 shift-reduce conflict due to the classical
-- ambiguous if () {} else {}
-- putting a "fi" at the end of an if statement solves those, but
-- breaks current SFDL syntax.

---------------


-----------
-- ordinary rules
-----------

-- program
Prog.           Prog    ::= "program" Ident "{" [Dec] "}" ;

-- how are lists of Dec treated
--[].             [Dec]   ::= ;
--(:).            [Dec]   ::= Dec ";" [Dec] ;
separator Dec ";" ;

-- [].             [Stm]   ::= ;
-- (:).            [Stm]   ::= Stm [Stm] ;

-- only an Assignment statement needs a ";" terminator, so specify
-- that only there
terminator Stm "" ;


-- this is needed for Ident lists in enum types and var declarations.
separator nonempty Ident "," ;


-- declarations
ConstDecl.      Dec     ::= "const" Ident "=" Exp ;
TypeDecl.       Dec     ::= "type"  Ident "=" Typ ;
-- TypeDecl.       Dec     ::= "typedef"  Typ Ident ;
VarDecl.        Dec     ::= "var"   Typ [Ident] ;
FunDecl.        Dec     ::= "function" Typ Ident "(" [FieldDecl] ")"
                            "{" [Dec] [Stm] "}" ;
TypedFunDecl.   Dec     ::= "function" Typ Ident "(" [FieldDecl] ")" ":" Typ
                            "{" [Dec] [Stm] "}" ;

-----------
-- types
-----------

-- NOTE: semantically, the size Exp for Int and arrays has to be a
-- compile-time integer constant

-- FIXME: the bitsize of an Int should be an expression (even if a
-- compile-time exp) and not just an Integer. This is not doable with
-- this parse arrangement though, unless the <> syntax is dropped, eg
-- have:
IntT.          Typ         ::= "Int" "<" Exp "`>" ;
--IntT.          Typ         ::= "Int" "<" Exp ">" ;
--IntT.          Typ         ::= "Int" "<" Integer ">" ;
BoolT.          Typ     ::= "Boolean" ;
VoidT.          Typ     ::= "void" ;

StructT.       Typ         ::= "struct" "{" [FieldDecl] "}" ;
EnumT.          Typ     ::= "enum" "{" [Ident] "}" ;
ArrayT.        Typ        ::= Typ "[" Exp "]" ;
SimpleT.        Typ     ::= Ident ;

-- this is a declaration of a named typed variable, like in a function
-- param list, or struct field
FieldDecl.   FieldDecl   ::= Typ Ident ;

-- fields in a struct are separated by commas
-- a void type can be defined as an empty struct. (TODO: or should the
-- compiler define one?)
-- both the above requirements apply to function arg lists too
-- separator FieldDecl "," ;
-- [].             [FieldDecl]   ::= ;
-- (:).            [FieldDecl]   ::= FieldDecl "," [FieldDecl] ;
separator FieldDecl "," ;


-- statements
SBlock.   Stm      ::= "{" [Dec] [Stm] "}" ;

SAss.     Stm      ::= RVal "=" Exp ";" ;

-- none of these statements need a trailing semicolon. so, only
-- Assignment needs it (as specified above)
SFor.     Stm           ::= "for" "(" Ident "=" Exp "to" Exp ")" Stm ;
SIf.      Stm      ::= "if" "(" Exp ")" Stm ;
SIfElse.        Stm     ::= "if" "(" Exp ")" Stm "else" Stm ;

-- to allow extra semicolons; no effect on the AST
-- causes 3 shift-reduce conflicts
_.        Stm      ::= Stm ";" ;


RVal.           RVal    ::= Exp ;

--------------
-- expressions
--------------

EIdent.   Exp13     ::= Ident ;
EInt.     Exp13     ::= Integer ;
-- EString.  Exp13     ::= String ;
ETrue.          Exp13    ::= "true" ;
EFalse.         Exp13    ::= "false" ;


EArr.           Exp12   ::= Exp12 "[" Exp "]" ;
EStruct.        Exp12   ::= Exp12 "." Exp13 ;

-- this causes some shift-reduce conflicts
EFunCall.       Exp12   ::= Ident "(" [FunArg] ")" ;

-- binary operators, grouped by precedence, numbered as in the C
-- operator precedence man page (some are missing here, hence the gap
-- 4-6)
ENot.           Exp11   ::= "!" Exp12 ;
-- this appears to cause a bunch of shift-reduce conflicts
ENeg.           Exp11   ::= "-" Exp12 ;
EBNot.          Exp11   ::= "~" Exp12 ;

ETimes.         Exp10   ::= Exp10 "*" Exp11 ;
EDiv.           Exp10   ::= Exp10 "/" Exp11 ;

EPlus.          Exp9    ::= Exp9 "+" Exp10 ;
EMinus.         Exp9    ::= Exp9 "-" Exp10 ;

ESL.            Exp8    ::= Exp9 "<<" Exp9 ;
ESR.            Exp8    ::= Exp9 ">>" Exp9 ;

ELt.            Exp7    ::= Exp8 "<" Exp8 ;
EGt.            Exp7    ::= Exp8 ">" Exp8 ;
ELtEq.          Exp7    ::= Exp8 "<=" Exp8 ;
EGtEq.          Exp7    ::= Exp8 ">=" Exp8 ;

EEq.            Exp6    ::= Exp7 "==" Exp7 ;
ENeq.           Exp6    ::= Exp7 "!=" Exp7 ;

EBAnd.          Exp5    ::= Exp5 "&" Exp6 ;
EBXor.          Exp4    ::= Exp4 "^" Exp5 ;
EBOr.           Exp3    ::= Exp3 "|" Exp4 ;

EAnd.           Exp2    ::= Exp2 "&&" Exp3 ;
EOr.            Exp1    ::= Exp1 "||" Exp2 ;

coercions Exp 13 ;


-- function call arguments
-- this causes some shift-reduce conflicts
FunArg.         FunArg  ::= Exp ;
separator FunArg "," ;



-- pragmas

-- type annotated expression. this node will only be added by the
-- typechecker, but the pretty-printer will print it following this
-- syntax
internal ExpT. Exp ::= Typ "(" Exp ")" ;

-- a Type constructor for a function type (which is not syntactically declared,
-- nor added to the AST), to hold a function's type in the TypeTable
--                          return type    param types
internal FuncT. Typ     ::= Typ            [Typ] ;

-------
-- "reduced" types, which are described by simpler types than the originals
-------
-- IntT with just an interger size, not an Exp
internal RedIntT.       Typ     ::= Integer ;
-- ArrayT with an interger size
internal RedArrayT.     Typ     ::= Typ Integer ;
-- a reduced EnumT?


-- a coercion expression! right now only for the bitsize of Int values.
internal ECoerce.       Exp     ::= Integer Exp ;


-- these should really be internal, as they are not used by the concrete syntax,
-- but internally by FuncT the typechecker. BNFC does not do internal list defs
-- though
-- results in 2 unused rules by Happy
[].    [Typ]   ::= ;
(:).   [Typ]   ::= Typ [Typ] ;


comment "/*" "*/" ;
comment "//" ;

entrypoints Prog, Stm, Exp ;
